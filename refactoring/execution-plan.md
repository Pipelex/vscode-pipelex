# MTHDS Syntax Coloring Refactoring: Execution Plan

This is a self-contained guide for refactoring the MTHDS syntax coloring to best-practice quality. It can be executed by someone (or Claude Code) with no prior context — all file paths, current code issues, and target architecture are documented here.

Read the companion files before starting:
- `refactoring/syntax-coloring-review.md` — full code review with 21 findings
- `refactoring/syntax-coloring-web-portability.md` — web portability analysis

---

## Design Principle: Zero Upstream Changes

This repo is a fork of [tamasfe/taplo](https://github.com/tamasfe/taplo). To minimize merge conflicts when syncing upstream, **no upstream Taplo files are modified**. All MTHDS-specific code is self-contained in dedicated directories:

- `editors/vscode/src/syntax/mthds/` — MTHDS grammar generator (new)
- `editors/vscode/src/pipelex/` — MTHDS extension code (existing)
- `test-data/mthds/` — MTHDS test fixtures (new)

The MTHDS generator duplicates ~190 lines of TOML base rules (comments, escapes, strings, numbers, booleans, datetime) with `.mthds` scope suffixes rather than extracting shared modules that would require modifying upstream files. This is a deliberate trade-off: minor duplication in exchange for clean upstream merges.

**Files that must NOT be modified** (upstream Taplo):
- `editors/vscode/src/syntax/index.ts`
- `editors/vscode/src/syntax/comment.ts`
- `editors/vscode/src/syntax/literal/*.ts`
- `editors/vscode/src/syntax/composite/*.ts`

---

## Current File Inventory

| File | Lines | Role | Status |
|------|-------|------|--------|
| `editors/vscode/mthds.tmLanguage.json` | 938 | Generated TextMate grammar (MTHDS) | **DONE** (Phase 1) — generated by `src/syntax/mthds/` |
| `editors/vscode/src/pipelex/semanticTokenProvider.ts` | 143 | VS Code semantic token provider | **DONE** (Phase 2) — rewritten |
| `editors/vscode/src/pipelex/pipelexExtension.ts` | 21 | Feature registration entry point | **DONE** (Phase 2) — setting check added |
| `editors/vscode/mthds.frontmatter.tmLanguage.json` | 22 | Frontmatter injection grammar | No change needed |
| `editors/vscode/mthds.markdown.tmLanguage.json` | 44 | Markdown code block injection grammar | No change needed |
| `editors/vscode/package.json` | 610 | Extension manifest | **DONE** (Phases 1-3) — build script, setting, colors |
| `docs/pipelex/syntax-color-palette.md` | 49 | Color palette documentation | **DONE** (Phase 3) — theme inheritance documented |
| `editors/vscode/src/syntax/index.ts` | 43 | TOML grammar generator entry point | No change (upstream) |
| `editors/vscode/src/syntax/comment.ts` | 26 | TOML comment rules | No change (upstream) |
| `editors/vscode/src/syntax/literal/*.ts` | ~190 | TOML literal rules | No change (upstream) |
| `editors/vscode/src/syntax/composite/*.ts` | ~200 | TOML composite rules | No change (upstream) |
| `editors/vscode/src/syntax/mthds/index.ts` | — | MTHDS grammar generator entry point | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/comment.ts` | — | MTHDS comment and commentDirective rules | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/table.ts` | — | MTHDS table rules (concept, pipe, generic) | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/entry.ts` | — | MTHDS entry rules | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/value.ts` | — | MTHDS value rule (strings, escapes, numbers, etc.) | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/jinja.ts` | — | Jinja2 template content rules | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/html.ts` | — | HTML-in-template rules | **DONE** (Phase 1) |
| `editors/vscode/src/syntax/mthds/injection.ts` | — | Data injection and template variable rules | **DONE** (Phase 1) |
| `test-data/example.mthds` | 82 | MTHDS test fixture | Reference for test writing |
| `test-data/discord_newsletter.mthds` | 129 | MTHDS test fixture (complex) | Reference for test writing |

### Files Still to Create (Phase 4)

| File | Role |
|------|------|
| `test-data/mthds/*.mthds` | TextMate grammar test fixtures (6 files) |
| `editors/vscode/src/pipelex/__tests__/semanticTokenProvider.test.ts` | Semantic token provider unit tests |

---

## Canonical MTHDS Language Rules

Establish these as the source of truth. Both TextMate and semantic provider must agree:

| Element | Format | Examples |
|---------|--------|----------|
| **Pipe name** | `[a-z][a-z0-9_]*` (lowercase, underscores only) | `analyze_features`, `write_newsletter` |
| **Concept name** | `[A-Z][A-Za-z0-9]*` (PascalCase) | `FeatureAnalysis`, `Text` |
| **Namespaced concept** | `namespace.ConceptName` where namespace is `[a-z][a-z0-9_]*` | `images.Photo`, `native.Image` |
| **Pipe type** | `Pipe[A-Z][A-Za-z0-9]*` (PascalCase, Pipe prefix) | `PipeLLM`, `PipeSequence`, `PipeImgGen` |
| **Data injection** | `@variable_name` (only in basic strings) | `@photo`, `@feature_analysis` |
| **Template variable** | `$variable_name` (only in basic strings) | `$weekly_summary` |
| **Model sigil** | `[$@~]identifier` (only in `model = "..."`) | `$gpt-4`, `@my-alias`, `~waterfall` |
| **Concept table** | `[concept.Name]` or `[concept]` (single level) | `[concept.FeatureAnalysis]` |
| **Pipe table** | `[pipe.name]` or `[pipe]` | `[pipe.analyze_features]` |

---

## Phase 0: Preparation (DONE)

**Goal:** Set up the workspace and verify you can build.

### Steps

1. **Read the review documents** in `refactoring/` to understand all issues.

2. **Verify current build works:**
   ```bash
   cd editors/vscode && yarn install && yarn build:syntax
   ```
   This runs `ts-node src/syntax/index.ts` which generates `toml.tmLanguage.json`.

3. **Take a snapshot** of the current `mthds.tmLanguage.json` for diff comparison later:
   ```bash
   cp editors/vscode/mthds.tmLanguage.json refactoring/mthds.tmLanguage.BEFORE.json
   ```

4. **Create the directory structure:**
   ```bash
   mkdir -p editors/vscode/src/syntax/mthds
   mkdir -p test-data/mthds
   ```

### Verification
- `yarn build:syntax` succeeds
- Directory structure is in place

---

## Phase 1: Build the MTHDS Grammar Generator (DONE)

**Goal:** Create a self-contained TypeScript generator that produces a correct, deduplicated `mthds.tmLanguage.json` — without modifying any upstream Taplo files.

**Status:** Completed. Commit `eea9ba6`. All verification checks passed:
- `yarn build:syntax` generates both grammars
- `toml.tmLanguage.json` is byte-identical to upstream
- Generated `mthds.tmLanguage.json`: 938 lines (down from 1065, -12%)
- Top-level patterns: 5 (was 12) — no jinja/html/injection leakage
- Repository: 13 keys — 7 duplicate rules eliminated
- `variable.other.jinja.mthds` only in `jinjaStatements`/`jinjaExpressions`
- Concept table regex tightened to `[A-Z]` prefix; pipe table to `[a-z][a-z0-9_]*`
- New entry patterns: `type = "PipeType"` and `pipe = "pipe_name"`
- Zero upstream files modified

### Architecture

```
editors/vscode/src/syntax/mthds/
  index.ts          # Entry point: assembles and writes mthds.tmLanguage.json
  comment.ts        # Comment and commentDirective rules (self-contained, .mthds scopes)
  table.ts          # [concept.X], [pipe.X], generic tables, inline tables
  entry.ts          # MTHDS-specific entries (pipe, output, refines, model, jinja2, prompt_template, generic)
  value.ts          # Value rule: strings (with MTHDS patterns), escapes, numbers, booleans, datetime
  jinja.ts          # jinjaTemplateContent, jinjaStatements, jinjaExpressions
  html.ts           # htmlContent, htmlAttributes
  injection.ts      # dataInjection, templateVariable (single definition each)
```

### Self-Contained Base Rules

The MTHDS generator defines its own copies of rules that are structurally identical to TOML but use `.mthds` scope suffixes. These are small and unlikely to change upstream:

#### `comment.ts` — Comment rules (~30 lines)

```typescript
// Self-contained MTHDS comment rules (parallel to upstream src/syntax/comment.ts)
const lang = "mthds";

export const comment = {
  captures: {
    1: { name: `comment.line.number-sign.${lang}` },
    2: { name: `punctuation.definition.comment.${lang}` },
  },
  comment: "Comments",
  match: "\\s*((#).*)$",
};

export const commentDirective = {
  captures: {
    1: { name: `meta.preprocessor.${lang}` },
    2: { name: `punctuation.definition.meta.preprocessor.${lang}` },
  },
  comment: "Comments",
  match: "\\s*((#):.*)$",
};
```

#### `value.ts` — Strings, escapes, numbers, booleans, datetime (~120 lines)

This file defines:
- **Escape sequences** (valid + invalid escapes, mirroring upstream `literal/string.ts` lines 1-10)
- **String patterns** (block + single basic strings with MTHDS-specific content patterns; literal strings with no content patterns)
- **Numbers** (float, integer, special, leading-zero formats — mirroring upstream `literal/number.ts`)
- **Booleans** (true/false — mirroring upstream `literal/boolean.ts`)
- **Datetime** (offset, local datetime, date, time — mirroring upstream `literal/datetime.ts`)

The key difference from TOML strings: basic (double-quoted) strings include `#jinjaTemplateContent`, `#htmlContent`, `#stringEscapes`, `#dataInjection`, `#templateVariable` as child patterns. Literal (single-quoted) strings include nothing — they are raw text per TOML spec.

The value rule assembles all of these into a single `patterns` array, ordered correctly (block before single for strings, float before integer for numbers, etc.).

### Key Design Decisions

#### Top-level patterns — ONLY structural TOML

```typescript
// mthds/index.ts
patterns: [
  { include: "#commentDirective" },
  { include: "#comment" },
  { include: "#table" },
  { include: "#entryBegin" },
  { include: "#value" },
]
```

**No** `#dataInjection`, `#templateVariable`, `#jinjaDelimiters`, `#jinjaKeywords`, `#jinjaVariable`, `#htmlTag`, `#htmlComment` at top level. This fixes review issues 1.2 and 1.3.

#### Single definition of each pattern — use `#include` references

Each pattern is defined once in the repository and referenced via `#include`:

```typescript
// injection.ts — ONE definition of dataInjection
export const dataInjection = {
  match: "(@)([a-z][a-zA-Z0-9_]*(?:\\.[a-z][a-zA-Z0-9_]*)*)",
  captures: {
    1: { name: "punctuation.definition.data-injection.mthds" },
    2: { name: "variable.name.data.mthds" },
  },
};
```

Both `jinja2`/`prompt_template` entry patterns and basic string patterns include `#dataInjection` — no duplication.

#### Jinja variables only inside delimiters

The `variable.other.jinja.mthds` scope is only produced inside `jinjaStatements` and `jinjaExpressions` (inside `{% %}` and `{{ }}`), never at top level or in the `value` rule. This fixes the overly broad identifier match (review issue 1.2).

#### Strings: MTHDS patterns only in basic (double-quoted) strings

Basic strings (`"..."` and `"""..."""`) include `#jinjaTemplateContent`, `#htmlContent`, `#stringEscapes`, `#dataInjection`, `#templateVariable`.

Literal strings (`'...'` and `'''...'''`) include nothing — they are raw text per TOML spec.

#### MTHDS-specific entry rules

The `entryBegin` module defines these patterns **in priority order**:

1. `pipe.name =` (pipe entry)
2. `output = "ConceptType"` (with concept coloring inside the string)
3. `refines = "ConceptType"` (same)
4. `type = "PipeType"` (with pipe type coloring)
5. `model = "$sigil-ref"` (with sigil + model ref coloring)
6. `jinja2 = """..."""` (begin/end, includes jinja/html/injection content)
7. `jinja2 = "..."` (single-line variant)
8. `prompt_template = """..."""` (begin/end, includes jinja/injection content, no html)
9. `prompt_template = "..."` (single-line variant)
10. `pipe = "pipe_name"` (pipe name inside step inline table — add coloring for the value)
11. Generic entry (fallback: `key = `)

For item 10, add a new pattern to colorize the pipe name value in step objects like `{ pipe = "analyze_features" }`. Currently the TextMate grammar doesn't distinguish this from any other string value — it relies on the semantic provider. The new grammar should add:

```typescript
{
  name: "meta.entry.pipe-ref.mthds",
  match: '\\s*(pipe)\\s*(=)\\s*(")((?:[a-z][a-z0-9_]*))(")' ,
  captures: {
    1: { name: "support.type.property-name.mthds" },
    2: { name: "punctuation.eq.mthds" },
    3: { name: "punctuation.definition.string.begin.mthds" },
    4: { name: "support.function.pipe-name.mthds" },
    5: { name: "punctuation.definition.string.end.mthds" },
  }
}
```

Similarly, add a pattern for `type = "PipeType"`:

```typescript
{
  name: "meta.entry.pipe-type.mthds",
  match: '\\s*(type)\\s*(=)\\s*(")(Pipe[A-Z][A-Za-z0-9]*)(")\\s*$',
  captures: {
    1: { name: "support.type.property-name.mthds" },
    2: { name: "punctuation.eq.mthds" },
    3: { name: "punctuation.definition.string.begin.mthds" },
    4: { name: "support.type.pipe-type.mthds" },
    5: { name: "punctuation.definition.string.end.mthds" },
  }
}
```

#### Table rules: aligned regexes

Use the canonical format from the rules table above:

```typescript
// Concept table: [concept.PascalName]
match: '^\\s*(\\[)\\s*(concept(?:\\.[A-Z][A-Za-z0-9]*)?)\\s*(\\])'

// Pipe table: [pipe.snake_name]
match: '^\\s*(\\[)\\s*(pipe(?:\\.[a-z][a-z0-9_]*)?)\\s*(\\])'
```

### Generator Entry Point

```typescript
// editors/vscode/src/syntax/mthds/index.ts
import * as path from "path";
import { writeFileSync } from "fs";
import { comment, commentDirective } from "./comment";
import { dataInjection, templateVariable } from "./injection";
import { value, stringEscapes } from "./value";
import { jinjaTemplateContent, jinjaStatements, jinjaExpressions } from "./jinja";
import { htmlContent, htmlAttributes } from "./html";
import { table } from "./table";
import { entryBegin } from "./entry";

const syntax = {
  version: "1.0.0",
  scopeName: "source.mthds",
  uuid: "8b4e5008-c50d-11ea-a91b-54ee75aeeb97",
  information_for_contributors: [
    "Originally was maintained by aster (galaster@foxmail.com). This notice is only kept here for the record, please don't send e-mails about bugs and other issues.",
  ],
  patterns: [
    { include: "#commentDirective" },
    { include: "#comment" },
    { include: "#table" },
    { include: "#entryBegin" },
    { include: "#value" },
  ],
  repository: {
    comment,
    commentDirective,
    table,
    entryBegin,
    value,
    jinjaTemplateContent,
    jinjaStatements,
    jinjaExpressions,
    htmlContent,
    htmlAttributes,
    dataInjection,
    templateVariable,
    stringEscapes,
  },
};

writeFileSync(
  path.resolve(__dirname, path.join("..", "..", "..", "mthds.tmLanguage.json")),
  JSON.stringify(syntax, null, 2)
);
```

### Build Script Update

Modify `editors/vscode/package.json` `scripts.build:syntax`:

```json
"build:syntax": "ts-node --project node.tsconfig.json src/syntax/index.ts && ts-node --project node.tsconfig.json src/syntax/mthds/index.ts"
```

### Verification

1. Run `yarn build:syntax` — both `toml.tmLanguage.json` and `mthds.tmLanguage.json` are generated.
2. Verify `toml.tmLanguage.json` is **unchanged** (upstream generator untouched).
3. Diff the generated `mthds.tmLanguage.json` against `refactoring/mthds.tmLanguage.BEFORE.json`:
   - It should be **smaller** (no duplication).
   - The top-level `patterns` should only contain 5 entries (comment, commentDirective, table, entryBegin, value).
   - The repository should contain single definitions of `dataInjection`, `templateVariable` (not `dataInjectionInString`/`templateVariableInString` duplicates).
   - No `jinjaVariable` rule at the repository top level.
4. Open `test-data/example.mthds` and `test-data/discord_newsletter.mthds` in VS Code with the rebuilt extension. Verify:
   - `[concept.FeatureAnalysis]` — "concept" in teal, "FeatureAnalysis" in teal
   - `[pipe.analyze_features]` — "pipe" in red, "analyze_features" in red
   - `type = "PipeLLM"` — "PipeLLM" colored as pipe type
   - `output = "FeatureAnalysis"` — "FeatureAnalysis" colored as concept
   - `@photo` inside `prompt_template = """..."""` — sigil pink, variable green
   - `$weekly_summary` inside `jinja2 = """..."""` — sigil pink, variable green
   - `{{ channel }}` — delimiters pink, "channel" green
   - `{% for ... %}` — delimiters pink, "for" cyan keyword
   - `<h2>` — tag name orange
   - Plain string values like `definition = "..."` — NOT colored as Jinja variables
   - Bare identifiers outside strings — NOT colored

---

## Phase 2: Rewrite the Semantic Token Provider (DONE)

**Goal:** Slim the provider down to only provide truly semantic information that TextMate cannot, fix all bugs.

**Status:** Completed. Commit `5227577`. Key changes:
- Slimmed from 121 lines to 143 lines (more capability: multi-line inputs, declaration modifiers)
- Removed TextMate-duplicated logic: `type = "PipeType"`, `model = "$ref"`, `pipe = "pipe_name"` — all now handled by grammar
- Removed `{ type = "text" }` heuristic — regexes are now precise
- Added `declaration` modifier (built-in VS Code modifier) to table header tokens
- Added multi-line `inputs = { ... }` state machine for concept type + variable coloring
- All position calculations use cumulative capture group lengths — zero `indexOf` calls
- All regexes anchored to `^` where applicable, canonical `[a-z][a-z0-9_]*` for pipe names
- Added `pipelex.mthds.semanticTokens` setting (default: true) to toggle provider
- Updated `pipelexExtension.ts` to check setting before registering provider

### What the Semantic Provider Does Now

The TextMate grammar (Phase 1) handles all lexical coloring. The semantic provider adds only what TextMate cannot:

1. **Declaration modifiers** on table headers:
   - `[concept.Name]` → `mthdsConceptSection` (keyword) + `mthdsConcept` (name), both with `declaration` modifier
   - `[pipe.name]` → `mthdsPipeSection` (keyword) + `mthdsPipeName` (name), both with `declaration` modifier

2. **Concept type references** in `output`/`refines` entries:
   - `output = "FeatureAnalysis"` → `mthdsConcept` (no modifier = reference)
   - `refines = "images.ImgGenPrompt"` → `mthdsConcept` (no modifier = reference)

3. **Input parameter coloring** (single-line and multi-line):
   - `inputs = { photo = "native.Image" }` → `mthdsDataVariable` (key) + `mthdsConcept` (value)
   - Multi-line `inputs = { ... }` blocks tracked with a state machine

4. **Result variable coloring** in step objects:
   - `result = "first_result"` → `mthdsDataVariable`
   - `batch_as = "item"` → `mthdsDataVariable`
   - `batch_over = "items"` → `mthdsDataVariable`

### Implementation Deviations from Original Plan

- **No custom `semanticTokenModifiers`**: Used VS Code's built-in `declaration` modifier instead of registering a custom `mthdsDeclaration` modifier. Simpler and theme authors can target `*.declaration` style.
- **No semantic tokens for `pipe = "name"` references**: TextMate grammar's `meta.entry.pipe-ref.mthds` pattern already colors these, so semantic overlay is unnecessary.
- **Kept `result/batch_as/batch_over` handling**: Not in original plan's "ONLY add" list, but these fill a gap TextMate can't handle (variable names inside step inline table string values).

### Architecture (as implemented)

```
semanticTokenProvider.ts (143 lines)
  TOKEN_TYPES        — named constants for 7 token type indices
  TOKEN_MODIFIERS    — named constant for declaration modifier
  DECLARATION_FLAG   — precomputed bitmask (1 << 0)

  provideDocumentSemanticTokens()  — main loop with multi-line inputs state machine
  analyzeTableHeaders()            — [concept.X] / [pipe.X] with declaration modifier
  analyzeOutputRefines()           — output/refines = "ConceptType"
  analyzeInputEntries()            — var = "ConceptType" inside inputs blocks
  analyzeResultVariables()         — result/batch_as/batch_over = "var_name"
```

All methods except `provideDocumentSemanticTokens` and `getSemanticTokensLegend` are private.

---

## Phase 3: Fix Color Configuration (DONE)

**Goal:** Unified, correct, non-aggressive color setup.

**Status:** Completed. Key changes:
- 3a: Unified pipe section color `#FF6666` -> `#FF6B6B` (now consistent with palette)
- 3b: Removed phantom scope `support.type.concept.native.mthds` (no grammar rule existed)
- 3c: Removed 6 theme-handleable textMateRules (Jinja punctuation, keywords, variables; HTML tags, attributes, comments) — these now inherit from user's theme
- 3d: Updated `docs/pipelex/syntax-color-palette.md` — secondary colors section now documents theme inheritance
- Remaining textMateRules: 10 MTHDS-specific scopes (down from 16)

### 3a. Unify the Two Reds

In `package.json` `configurationDefaults.textMateRules`, change `#FF6666` to `#FF6B6B` for `support.type.property-name.pipe.mthds`. This makes all pipe-related colors consistent with the palette doc.

### 3b. Remove Phantom Scope

Remove the `support.type.concept.native.mthds` rule from `configurationDefaults.textMateRules` (lines 288-293 in current package.json). It has no corresponding grammar rule.

### 3c. Reduce Hardcoded Overrides

The current 15 textMateRules override user themes aggressively. Reduce to only MTHDS-custom scopes that no standard theme would color:

**Keep** (MTHDS-specific scopes):
- `support.type.property-name.pipe.mthds`
- `support.type.pipe-type.mthds`
- `support.type.property-name.concept.mthds`
- `support.type.concept.mthds`
- `support.function.pipe-name.mthds`
- `punctuation.definition.data-injection.mthds`
- `punctuation.definition.template-variable.mthds`
- `punctuation.definition.model-sigil.mthds`
- `entity.name.model-ref.mthds`

**Remove** (standard scopes that themes already handle):
- `punctuation.definition.jinja.mthds` -> falls back to theme's punctuation color
- `keyword.control.jinja.mthds` -> falls back to theme's keyword color
- `variable.other.jinja.mthds` -> falls back to theme's variable color
- `entity.name.tag.html.mthds` -> falls back to theme's HTML tag color
- `entity.other.attribute-name.html.mthds` -> falls back to theme's attribute color
- `comment.block.html.mthds` -> falls back to theme's comment color

### 3d. Update Palette Doc

Update `docs/pipelex/syntax-color-palette.md` to reflect the actual colors after unification. Remove the `#FF6666` reference. Note that Jinja/HTML colors now inherit from the user's theme.

### Verification

1. Install in VS Code with Dracula theme — MTHDS-specific elements have the palette colors, Jinja/HTML use Dracula's native colors.
2. Switch to a light theme — Jinja/HTML keywords are readable (they use the theme's colors), MTHDS-specific elements use the hardcoded dark-optimized colors (acceptable for now).
3. Verify no scope in `textMateRules` references a scope that doesn't exist in the grammar.

---

## Phase 4: Add Tests

**Goal:** Prevent regressions.

### 4a. TextMate Grammar Snapshot Tests

Create test fixtures in `test-data/mthds/` that cover edge cases. Use `vscode-tmgrammar-test` (or a similar tool) to generate scope snapshots.

**Test fixtures to create:**

`test-data/mthds/concept-tables.mthds`:
```toml
[concept]
Name = "Description"

[concept.FeatureAnalysis]
definition = "Analysis of features"

[concept.FeatureAnalysis.structure]
field = { type = "text", required = true }
```

`test-data/mthds/pipe-definitions.mthds`:
```toml
[pipe]

[pipe.analyze_features]
type = "PipeLLM"
definition = "Analyze features"
inputs = { photo = "native.Image" }
output = "FeatureAnalysis"
model = "$gpt-4o"
```

`test-data/mthds/jinja-templates.mthds`:
```toml
[pipe.format]
type = "PipeJinja2"
jinja2 = """
{% for item in items %}
  <h2>{{ item.title }}</h2>
  <p>{{ item.body | truncate(200) }}</p>
{% endfor %}
<!-- end -->
"""
```

`test-data/mthds/prompt-templates.mthds`:
```toml
[pipe.ask]
type = "PipeLLM"
prompt_template = """
Analyze this:
@input_data

Using template: $template_name

Be concise.
"""
```

`test-data/mthds/false-positives.mthds`:
```toml
# This file tests that plain strings are NOT colored as Jinja/HTML/injections
[concept.PlainText]
definition = "A simple text concept with words that could false-match"
description = "The variable foo should not be colored"
note = 'Literal string: @not_injection $not_template {{ not_jinja }}'
```

`test-data/mthds/steps.mthds`:
```toml
[pipe.sequence]
type = "PipeSequence"
steps = [
    { pipe = "step_one", result = "first_result" },
    { pipe = "step_two", batch_over = "items", batch_as = "item", result = "second_result" },
]
```

### 4b. Semantic Token Provider Unit Tests

Create `editors/vscode/src/pipelex/__tests__/semanticTokenProvider.test.ts`:

- Mock `vscode.TextDocument` with `lineCount`, `lineAt(n).text` returning fixed content
- Mock `vscode.SemanticTokensBuilder` to capture pushed tokens
- Call `provideDocumentSemanticTokens()` (public API) on the mock document
- Assert token positions, lengths, types, and modifiers from captured pushes

**Test cases to cover:**

1. **Table headers with declaration modifier:**
   - `[concept.FeatureAnalysis]` → `mthdsConceptSection` at "concept", `mthdsConcept` at "FeatureAnalysis", both with `declaration` flag
   - `[pipe.analyze_features]` → `mthdsPipeSection` at "pipe", `mthdsPipeName` at "analyze_features", both with `declaration` flag
   - `[concept]` and `[pipe]` alone (no name part)

2. **Output/refines concept references (no modifier):**
   - `output = "FeatureAnalysis"` → `mthdsConcept` at correct offset
   - `refines = "images.ImgGenPrompt"` → `mthdsConcept` (namespaced)
   - `output = "FeatureAnalysis" # comment` → still matches

3. **Single-line inputs:**
   - `inputs = { photo = "native.Image" }` → `mthdsDataVariable` for "photo", `mthdsConcept` for "native.Image"
   - `inputs = { a = "TypeA", b = "TypeB" }` → two variable + concept pairs

4. **Multi-line inputs (state machine):**
   - Document with `inputs = {\n    photo = "native.Image",\n    text = "Text"\n}` → tokens on correct lines

5. **Result variables:**
   - `{ pipe = "step_one", result = "first_result" }` → `mthdsDataVariable` for "first_result"
   - `{ batch_over = "items", batch_as = "item" }` → two `mthdsDataVariable` tokens

6. **False positives (should produce NO tokens):**
   - `definition = "Some description"` — not an output/refines/inputs line
   - `{ type = "text", required = true }` — concept structure, not inputs
   - Lines inside template strings — semantic provider skips these

### Verification

- All tests pass.
- Run the TextMate grammar tests against the generated grammar.
- Run the semantic provider tests.

---

## Phase 5: Final Cleanup

### 5a. Delete Dead Files

- Remove `refactoring/mthds.tmLanguage.BEFORE.json` (snapshot from Phase 0)

### 5b. Update CLAUDE.md

The CLAUDE.md `Don't Edit` section should now include:
```
- `mthds.tmLanguage.json` — Generated by `src/syntax/mthds/`; run `yarn build:syntax`
```

(This was already listed as `*.tmLanguage.json` in the existing CLAUDE.md, but now it's actually true for MTHDS too.)

### 5c. Verify Full Build

```bash
cd editors/vscode
yarn build
```

The full build runs `build:syntax` (both TOML and MTHDS generators), then bundles the extension.

### 5d. Manual Visual Verification

Open both test fixtures in VS Code:
1. `test-data/example.mthds` — photo opposite pipeline
2. `test-data/discord_newsletter.mthds` — newsletter with Jinja2, HTML, batch operations

Verify every element is colored correctly per the palette:
- Concept names: teal (`#4ECDC4`)
- Pipe names/types/sections: coral red (`#FF6B6B`)
- Data variables: pale green (`#98FB98`)
- Sigils (`@`, `$`): magenta (`#FF79C6`)
- Jinja keywords: inherit from theme
- HTML tags: inherit from theme
- Plain strings: default string color, no false-positive Jinja coloring
- Comments: inherit from theme

---

## Summary: Files Changed Per Phase

| Phase | Status | Files Created | Files Modified | Files Deleted |
|-------|--------|---------------|----------------|---------------|
| 0 | DONE | `refactoring/mthds.tmLanguage.BEFORE.json`, directories | — | — |
| 1 | DONE | `mthds/index.ts`, `mthds/comment.ts`, `mthds/table.ts`, `mthds/entry.ts`, `mthds/value.ts`, `mthds/jinja.ts`, `mthds/html.ts`, `mthds/injection.ts` | `package.json` (build:syntax script) | `mthds.tmLanguage.json` (replaced by generated) |
| 2 | DONE | — | `semanticTokenProvider.ts` (rewrite), `pipelexExtension.ts`, `package.json` (new setting) | — |
| 3 | DONE | — | `package.json` (textMateRules: -6 rules, color fix), `docs/pipelex/syntax-color-palette.md` | — |
| 4 | TODO | `test-data/mthds/*.mthds` (6 fixtures), `semanticTokenProvider.test.ts` | — | — |
| 5 | TODO | — | `CLAUDE.md` (optional) | `refactoring/mthds.tmLanguage.BEFORE.json` |

**Upstream Taplo files modified: 0**

## Dependencies Between Phases

```
Phase 0 ──→ Phase 1 ──→ Phase 2
  DONE        DONE    ↗   DONE
                   Phase 3 ──→ Phase 4 ──→ Phase 5
                     DONE        TODO        TODO
```

- Phases 0-3: All complete
- **Phase 4 is next**: Both Phase 2 and Phase 3 are done, so Phase 4 can start immediately
- Phase 5 after Phase 4 (cleanup)
